# 런타임

자바스크림의 런타임
메모리 할당이 일어나는 힙과 콜 스택이 있다.

# 동기

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 그러므로 동시에 2개 이상의 함수를 동시에 실행할 수 없다. 이처럼 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드**방식으로 동작한다. 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 **블로킹(작업 중단)**이 발생한다. 즉, 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 **동기(Synchronous)처리**라고 한다.

- 장점: 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다.

- 단점: 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹된다.

# 비동기

현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 **비동기(asynchronous)처리**라고 한다.

- 장점: 블로킹이 발생하지 않는다.

- 단점: 태스크의 실행 순서가 보장되지 않는다.

비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용한다. 이는 콜백 헬을 발생시켜 가독성을 나쁘게 하고, 에러의 예외 처리가 곤란하며, 여러개 비동기 처리를 한 번에 처리하는 데도 한계가 있다.

비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다. 이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.

# 콜백 함수

1. 다른 함수가 부르는 함수다.

- forEach: 콜백이지만, 비동기적 x 자신의 자체적 스택에서 실행

2. 앞으로 큐에 쌓일 비동기식 함수

- setTimeout

# 렌더링

이미지처리나 애니메이션이 너무 많으면, 느려진다.

# setTimeout()

브라우저에서 제공하는 API다.
브라우저에서 Web API에서 돌아간다.
실행 중인 스택에 끼어들 수는 없다.
작동이 완료되면 콜백을 태스크큐에 밀어 넣는다.
스택이 비어있고 태스크 큐에 대기가 있으면
이벤트 루프가 스택에 넣어준다.
스택은 자바스크립트 영역이다.
setTimeout(0)스택이 비어있을때까지 기다리는 역할을 한다.
Web API에서 실행되는 동안 스택은 계속해서 실행되고
스택이 비면 태스크큐에서 이벤트 루프가 스택에 넣어주는 것이다!
여러개가 태스크 큐에 있으면 스택에서 순차적으로 실행한다.

setTimeout 함수는 일정 시간이 경과한 이후에 콜백 함수를 호출하지만, setTimeout 함수 이후의 태스크를 블로킹하지 않고 곧바로 실행한다. 타이머 함수인 setTimeout과 setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.

비동기 함수인 setTimeout의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면, 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 비로소 콜 스택에 푸시되어 실행된다.

# 이벤트 루프와 태스크 큐

자바스크립트의 동시성을 지원하는 것이 바로 **이벤트 루프**다. 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나다.

**태스크 큐**란 setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.

**이벤트 루프**란 콜스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다. 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.

# call stack, callback queue(stack queue)

실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 **콜 스택**이다. 함수를 호출하면 함수 실행 컨텍스트가 순차적을 콜 스택에 푸시되어 순차적으로 실행된다. 자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트(실행 중인 실행 컨텍스트)가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않는다.

이벤트 루프(event loop)를 통해서 callback queue에 callback함수가 stack으로 올라감

# Node.js 파일 읽기

- fs모듈

  - 비동기적: fs.readFile(filename, [options], callback)
    filename의 파일을 [options]의 방식으로 읽은 후 callback으로 전달된 함수를 호출

  - 동기적: fs.readFileSync(filename, [options])
    filename의 파일을 [options]의 방식으로 읽은 후 문자열을 반환한다.

  - Sync가 붙은 것은 동기적 읽기, 붙지 않은 것은 비동기적 읽기이다. 동기적 읽기로 읽게 되면 파일을 읽으면서 다른 작업을 동시에 할 수 없지만 비동기적으로 읽으면 동시에 다른 작업도 수행할 수 있다. 또한 파일을 다 읽으면 매개변수 callback으로 전달한 함수가 호출된다.

- read.line

read.line의 경우 입력을 비동기적으로 처리한다. 한 번에 한 줄씩 입력값을 받아오며 readline.Interface는 readline.createInterface() 메서드를 통해 생성 가능하다.

# 퀵 정렬과 병합 정렬

둘 다 평균적으로 0(1)의 성능을 갖고 있으며 Divide and Conquer(분할-정복) 알고리즘에 속한다. 둘 다 점점 탐색할 배열의 크기를 쪼개서 재귀함수에 넘겨준다.

- 병합 정렬은 반으로 쪼개어 배열을 분할한다.
- 퀵 정렬은 크게 두 가지 분할 방법이 있다. pibot(중심축)을 정하고, 중심축 보다 작은 값들은 왼쪽으로 큰 값들은 오른쪽으로 보낸다. 이 것이 재귀적으로 반복되면 결국 정렬이 완성된다.

- 퀵 정렬은 병합 정렬과 달리 다른 메모리 공간을 사용하지 않고 오직 재귀 콜 스택을 위한 메모리만 사용된다. 그에 반면 병합 정렬은 매번 새로운 배열을 만들어 내므로 메모리 사용량이 더 크다.
- 병합정렬은 stable 하지만, 퀵 정렬은 unstable 하다. (원소들 중에 같은 값이 있는 경우에 정렬 이후 순서가 초기 순서와 달라 질 수 있기 때문에)

# 퀵 정렬 ((Quick sort))

1.  Lomutos’ Partition (배열의 맨 마지막 값을 pivot으로 정하는 방식)
    인자로 들어온 start부터 이 끝에 있는 값(pivot) 전까지 pivot과 비교연산을 한다.

    1. 배열을 순회할 index 포인터
    2. pivotIndex 포인터

2.  Hoare’s Parition (물리적으로 배열의 중간값을 pivot으로 정하는 방식)

# 제너레이터(Generator)

function* 으로 선언하며 하나 이상의 yield 표현식을 포함한다.
애스터리스크(*)의 위치는 일관성을 유지하기 위해 function 키워드 바로 뒤에 붙인다. 제너레이터 함수는 화살표 함수로 정의할 수 없고 new 연산자와 함께 생성자 함수로 호출할 수 없다.

다른 작업을 하다가 다시 돌아와서 next()해주면 진행이 멈췄던 부분부터 이어서 실행 한다. 즉, yield 키워드와 next메서드를 통해 함수의 실행을 중간에 멈췄다가 재개할 수 있는 기능이다.함수 호출자에게 제어권을 양도하는 것이다.
무한 루프에서 break가 없어도 한 개씩만 나온다. 그래서 계산을 미룰 수 있고 값을 미리 만들어 두지 않아서 메모리 측면에서 효율적이다.

함수 호출자와 함수의 상태를 주고받을 수 있다. 이러한 특성을 활용하면 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현할 수 있다. 프로미스의 후속 처리 메서드 then/catch/finally 없이 비동기 처리 결과를 반환하도록 구현할 수 있다.

- next() : *yield된 값*을 value프로퍼티 값으로, 제너레이터 함수가 끝까지 실행되었는지를 나타내는 불리언 값을 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다. 제너레이터 객체의 next 메서드에 전달한 인수는 제너레이터 함수의 yield 표현식을 할당받는 변수에 할당된다.
  1->x->y

- return(), throw(): 이터레이터에는 없지만 제너레이터 객체에는 있다.

1. return(): *인수로 전달받은 값*을 value 프로퍼티 값으로, *true*를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.

2. throw(): 인수로 전달받은 에러를 발생시키고 *undefined*를 value 프로퍼티 값으로, *true*를 done프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.

제너레이터 객체란?

일반 함수는 호출하면 함수 코드 블록을 실행하지만 제너리엍 함수를 호출하면 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제너레이터 객체는 iterable이면서 iterator다. 제너레이터 객체의 next 메서드를 호출하면 제너레이터 함수의 코드 블록을 실행한다. 단, yield 표현식까지만 실행한다. **yield**키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오늘 표현식의 평과 결과를 제너레이터 함수 호출자에게 반환한다.

- 반복이 가능
- Symbol.iterator 메서드를 상속받는 iterable 이다.
- value와 done 속성을 가진 객체 iterator를 반환한다.
- 배열은 메서드를 가지고 있고 이 메서드가 반환하는 값이 iterator이므로
  iterable하다고 할 수 있다. 즉, 반복가능한 객체라는 것이다.

# async/await

제너레이터 함수를 실행하는 제너레이터 실행기이다. 프로미스를 기반으로 동작한다. 프로미스의 후속 처리 메서드로 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다.

async 함수는 언제나 프로미스를 반환한다. 명시적으로 반환하지 않더라도 암묵적으로 반환값을 resolve하는 프로미스를 반환한다. 클래스의 constructor 메서드는 인스턴스를 반환해야 하지만 async 함수는언제나 프로미스를 반환해야 한다.

await 키워드는 프로미스가 settled 상태 (비동기 처리가 수행된 상태)가 될 때까지 대기하다가 프로미스가 resolve한 처리 결과를 반호나한다. 반드시 프로미스 앞에서 사용해야 한다.모든 프로미스에 await 키워드를 사용하는 것은 주의해야 한다. 그러나 비동기 처리의 처리 순서가 보장되어야 하면 모든 프로미스에 await키워드를 써서 순차적으러 처리할 수 밖에 없다.

# 에러 처리의 한계

비동기 함수말고, aync/awiat에서는 try...catch 문을 사용해서 에러를 캐치할 수 있다. 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.
