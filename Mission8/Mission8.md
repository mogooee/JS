# 실행 컨텍스트

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념으로, 이를 통해 자바스크립트가 스코프를 기반으로 식별자와 시별자 바인딩을 관리하는 방식과 호이스팅이 발생하는 이유, 클로저의동작 방식, 그리고 태스크 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리의 동작 방식을 이해할 수 있다.

<br>

## # 소스코드

전역코드, 함수코드, eval 코드, 모듈 코드로 구분하며 소스코드를 평가(선언문)하여 실행 컨텍스트를 생성한다. 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 스코프)에 등록하면 소스코드 평가 과정이 마쳐진다.

이어서 선언문을 제외한 소스코드가 순차적으로 실행되는 런타임이 시작된다. 실행에 필요한 변수나 함수의 참조는 실행 컨텍스트가 관리하는 스코프에서 검색하여 취득하고 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행컨텍스트가 관리하는 스코프에 등록된다.

<br>

## # 실행 컨텍스트 스택

코드의 실행 순서를 관리하며 **콜 스택**이라고도 한다. 소스코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓인다. 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **실행 중인 실행 컨텍스트**라 부른다.

<br>

## # 렉시컬 환경

스코프와 식별자를 관리한다. let과 const는 블록 레벨 스코프를 가지므로 if문, for문 같은 모든 블록문이 실행될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다. 코드 블록의 실행이 종료되면 코드 블록을 위한 렉시컬 환경(BLOCK Lexical Environment)에서 코드 블록이 실행되기 이전의 렉시컬 환경(Global Lexical Environment)으로 되돌린다.

<br>
<br>

# Closure

일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다. 하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하게 된다. 이 같은 현상이 발생한 이유는 자바스크립트가 함수를 어디에 정의했는지에 따라 상위 스코프를결정하는 **렉시컬 스코프(정적 스코프)**를 따르는 프로그래밍 언어이기 때문이다.

### ✋ [[Environment]]

함수는 자신의 내부 슬롯[[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.

<br>

외부 함수는 생명 주기를 마쳤는데 중첩 함수가 더 오래 유지되어 이미 실행을 마친 외부 함수의 변수값을 참조할 수 있다. 이러한 중첩함수를 **클로저**라 부른다. 클로저에 의해 참조되는 상위 스코프의 변수를 **자유 변수**라 한다. 클로저란 '자유 변수에 묶여 있는 함수'라 할 수 있다. 클로저가 참조하고 있지 않는 식별자는 기억하지 않으므로 불필요한 메모리 낭비라고 볼 수 없다.

- 상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다.

- 외부 함수보다 일찍 소멸되는 중첩 함수는 클로저라고 하지 않는다.

<br>

## # 클로저의 활용

클로저는 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

```js
//즉시 실행 함수가 호출되고 반환한 함수가 increase 변수에 할당된다.
//즉시 실행 함수는 호출된 이후 소멸
const increase = (function () {
  //private 변수
  let num = 0;

  //클로저
  return function () {
    return ++num;
  };
})();

console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```

<br>

## # 스코프 레벨에 따라 클로저 생성 여부가 달라진다!

```js
//1. var는 함수레벨스코프로 i가 전역변수이므로 3이 출력된다. (for문 실행 순서: i++ -> i<3 )
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (var j = 0; j < func.length; j++) {
  console.log(funcs[j]()); //3 3 3
}

//2. 클로저를 사용해 위 예제를 바르게 동작하는 코드로 수정한 것
var funcs = [];

for (var i = 0; i < 3; i++) {
  //id는 즉시 실행 함수가 반환한 중첩함수에 묶여있는 자유 변수가 되어 그 값이 유지된다.
  funcs[i] = (function (id) {
    return function () {
      return id;
    };
  })(i);
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}

//3. let은 블록레벨스코프로 for문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다.
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); //0 1 2
}
```

**let**은 **블록레벨스코프**로 블록 안에서{} 값이 존재하고, 클로저 영역없이 i의 변수 값을 for문에따라 각각 갖는다.
**var**는 **함수레벨스코프**로 중첩 함수에 변수값이 없으므로 스코프 체인을 통해 상위 스코프를 사용하여 값을 참조한다.

<br>

## # 모듈 패턴

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 모듈 패턴의 특징은 전역 변수의 억제는 물론 **캡슐화(객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것)**까지 구현할 수 있다는 것이다. 즉 클로저를 통해 전역 변수를 억제할 수 있다.

<br>
<br>

# 즉시실행함수

## # 전역 변수의 문제점

1. 전역 변수는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용함으로써 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.
2. 전역 변수는 생명 주기가 길어 메모리 리소스도 오랜 기간 소비한다.
3. 스코프 체인 상에서 종점에 존재하므로 검색 속도가 가장 느리다.
4. 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유하므로 네임스페이스가 오염되어 다른 파일 내에서 동일한 이름을 가진 전역 변수나 전역 함수가 생겨 오류가 발생할 수 있다.

<br>

## # 전역 변수의 사용을 억제 하는 방법

함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출된다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.

```js
function((){
    var foo = 10; //즉시 실행 함수의 지역 변수
}());

console.log(foo); // ReferenceError: foo is not defined
```

<br>
<br>

# 타이머

## # 호출 스케줄링

함수를 일정 시간이 지난 후 호출되도록 하려면 타이머 함수를 사용한다. 이를 호출 스케줄링이라한다.

<br>

## # 타이머 함수 `setTimeout / setInterval`

두 번째 인수로 전달한 시간(ms)만큼 대기한 다음, 첫 번째 인수로 전달한 콜백 함수를 호출하는 타이머 함수다.
setTimeout 함수의 콜백 함수는 타이머가 만료되면 단 한 번 호출되고, setInterval 함수의 콜백 함수는 타이머가 만료될 때마다 호출된다. 타이머 함수는 **비동기 처리 방식**으로 동작한다.

<br>

## # 타이머 제거 함수 `clearTimeout / clearInterval`

타이머 함수는 타이머를 제거할 수 있는 clearTimeout 함수와 clearInterval 함수로 호출 스케줄링을 취소한다. setInterval 타이머 함수는 clearInterval 로 제거될 때까지 반복 실행한다.

<br>

## # 디바운스와 스로틀

scroll, resize, input, mousemove 같이 짧은 시간 간격으로 연속해서 발생하는 이벤트에 바인딩한 이벤트 핸들러는 과도하게 호출되어 성능에 문제를 일으킬 수 있다. 디바운스와 스로틀은 이러한 이벤트를 그룹화하여 과도한 이벤트 핸들러의 호출을 방지한다.

- 디바운스(debounce)

  짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.

  resize 이벤트 처리나 input 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지 처리 등에 유용하게 사용된다.

  delay가 경과하기 이전에 이벤트가 발생하면 이전 타이머를 취소하고 새로운 타이머를 재설정한다. 따라서 delay보다 짧은 간격으로 이벤트가 발생하면 callback은 호출되지 않는다.

- 스로틀(throttle)

  짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.

  scroll 이벤트 처리나 무한 스크롤 UI 구현 등에 유용하게 사용된다.

  delay가 경과하기 이전에 이벤트가 발생하면 아무것도 하지 않다가 delay가 경과했을 때 이벤트가 발생하면 새로운 타이머를 재설정한다. 따라서 delay 간격으로 callback이 호출된다.

<br>
<br>

# 비동기(Async)

## # 비동기 처리

현재 실행 중인 태스크가 종료되지 않을 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 **비동기 처리**라고 한다.

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 3 * 1000);
bar();
//bar 호출->(3초 경과 후) foo 호출
```

블로킹이 발생하지 않는다는 장점이 있지만 태스크의 실행 순서가 보장되지 않는다는 단점이 있다.

비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용한다. 이 콜백 패턴은 콜백 헬을 발생시켜 가독성을 나쁘게 하고, 비동기 처리 중 발생한 에러의 예외 처리가 곤란하며, 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있다. 이러한 문제점을 해결하기 위해서 *프로미스, 제너레이터*를 이용한다.

**⚠️ 타이머 함수인 setTimeout과 setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.**

<br>

## # 이벤트 루프와 태스크 큐

자바스크립트의 동시성을 지원하는 것이 바로 **이벤트 루프**이다. 자바스크립트 엔진은 크게 **콜 스택**과 **힙**으로 구분할 수 있다.

비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다. 예를 들어, 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다. 이를 위해 브라우저 환경은 **태스크 큐**와 **이벤트 루프**를 제공한다.

비동기 함수인 setTimeout(브라우저의 Web API)의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면, 이벤트 루프가 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.

<br>

❓ 브라우저 환경에서 다음 예제가 어떻게 동작할까?

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 0);
bar();
```

<br>
1.  전역 코드가 평가 되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시됨

2.  전역 코드가 실행되기 시작하여 setTimeout함수가 호출됨. 이때 setTimeout 함수의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 현재 실행 중인 실행컨텍스트가 됨 (브라우저의 Web API인 타이머 함수도 함수이므로 함수 실행컨텍스트를 생성)

3.  setTimeout 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝된다. 이때 *브라우저*가 호출 스케줄링, 즉 타이머 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시함

4.  브라우저와 자바스크립트 엔진의 병행처리

    4-1. _브라우저_: 브라우저는 타이머를 설정하고 타이머의 만료를 기다린다. 이후 타이머가 만료되면 콜백 함수 foo가 태스크 큐에 푸시된다. 최소 지연 시간 (4ms) 후에 콜백 함수 foo가 태스크 큐에 푸시되어 대기하게 된다.

    4-2. _자바스크립트 엔진_: bar 함수가 호출되어 bar함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 이후 bar 함수가 종료되어 콜 스택에서 팝된다. foo 함수는 아직 태스크 큐에서 대기 중이다.

5.  전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜스택에서 팜됨. 콜 스택에는 아무런 실행 컨텍스트도 존재하지 않음.

6.  이벤트 루프에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기 중인 콜백 함수 foo가 이벤트 루프에 의해 콜 스택에 푸시된다. 콜백 함수 foo의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 이후 foo함수가 종료되어 콜 스택에서 팝된다.

<br>

**🌠 요약: 콜 스택이 비면(전역 실행 컨텍스트까지 팝되면) 태스크 큐(콜백 큐)에 대기 중인 비동기 함수(브라우저가 타이머 설정, 만료 후 타이머 콜백 함수를 태스크 큐에 푸시함)가 이벤트 루프에 의해 콜스택으로 푸시된다.**

<br>
<br>

# API

![API](https://heysign.co.kr/wp-content/uploads/2021/08/api_kiosk-1024x612.png)

애플리케이션 프로그래밍 인터페이스(Application Programming Interface)의 약자로, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. 주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공한다. 다시 말해 API는 프로그램들이 서로 소통하는 방법으로, 애플리케이션 소프트웨어를 구축하고 통합하기 위한 일종의 체계, 혹은 규격이라고 볼 수 있다.

<br>
<br>

# 이벤트 핸들러

**이벤트가 발생했을 때 호출될 함수**를 말한다. 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 한다. 이벤트 핸들러 프로퍼티에 함수를 할당하면 해당 이벤트가 발생했을 때 할당한 함수가 브라우저에 의해 호출된다.

- addEventListener 메서드

```js
EventTarget.addEventListener('eventType','functionName[,useCaputre]);
```

이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무런 영향을 주지 않으므로 하나 이상의 이벤트 핸들러를 등록할 수 있다. 이벤트 핸들러는 등록된 순서대로 호출된다. 단, 참조가 동일한 이벤트 핸들러를 중복 들록하면 하나의 이벤트 핸들러만 등록된다.
