# 함수란?

- 인수: 호출 시에 넣어주는 입력
  모든 인수: arguments 객체의 프로퍼티로 보관된다. 초과된 인수도 얻을 수 있다.

- 매개변수: 함수 이름 옆에서 함수 내부로 입력을 전달받는 변수

- 반환값: return문으로 출력되는 값

- 함수 호출: 정의한 함수에 인수를 전달하면서 호출하면 매개변수를 통해 함수 내부에 인수가 들어가고, 반환값을 반환한다.

- 함수를 사용하는 이유: 함수를 통해 중복을 제거하고 코드의 재사용이 가능하다.유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.

- **함수는 호출할 수 있는 객체다.**
- 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다. 하지만 함수 리터럴은 변수에 할당할 수 있다.

- 함수 선언문 vs 함수 리터럴
- *함수 선언문*은 함수 이름을 생략할 수 없다.
- *함수 리터럴*의 이름을 생략하는 것을 익명함수라 한다.
- *함수 리터럴*은 값으로 평가 될 수 있는 표현식이다.
- *기명 함수 리터럴*을 단독으로 사용하면 함수 선언문으로 해석된다.
- *기명 함수 리터럴*의 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
-
- 함수는 함수 이름으로 호출하는 것이 아니라 자바스크립트 엔진이 암묵적으로 생성한 함수 객체를 가리키는 동일한 이름의 식별자로 호출한다. -> 함수 선언문은 자바스크립트 엔진이 식별자를 만들고, 함수 리터럴은 변수에 할당해주면 그 변수로 호출할 수 있다.

# 함수 호이스팅

함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 함수 선언문은 런타임 이전에 함수 객체가 생성되고 자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 생성된 함수 객체를 할당한다. 따라서 런타임에는 함수 선언문 이전에 함수를 참조하고 호출할 수 있다.

변수는 undefined로 초기화 되므로 함수 표현식으로 함수를 정의하고 함수 표현식 이전에 호출하면 변수 호이스팅이 발생하여 undefined를 출력한다.  
=> 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.

- 생성자함수
  : 객체를 생성하는 함수이다. 클로저를 생성하지 않는 등 바람직 하지 않다.

- 화살표 함수
  ```js
  const add = (x, y) => x + y;
  console.log(add(2, 5));
  ```
  화살표 함수는 생성자 함수로 사용할 수 없고, 기존 함수와 this 바인딩 방식이 다르다. prototype 프로퍼티가 없고, arguments 객체를 생성하지 않는다.
- 타입스크립트: 정적 타입을 선언할 수 있는 자바크립트의 상위 확장을 도입해서 부적절한 호출을 방지할 수 있다.

# 재귀 함수

반복문 없이 반복되는 처리를 위해 사용한다. 탈출 조건이 없으면 함수가 무한 호출되어 스택 오버플로(stack overflow) 에러가 발생한다.

# 중첩 함수

중첩 함수는 외부 함수 내부에서만 호출할 수 있다. 외부 함수의 헬퍼 함수의 역할을 한다.

# 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 말한다. 매개 변수를 통해 콜백 함수를 전달받은 함수를 고차 함수라고 한다. 고차 함수의 헬퍼 함수의 역할을 한다. 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리(이벤트 처리, Ajax통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.

# 순수 함수와 비순수 함수

객체와 같은 얕은 복사는 참조에 의한 호출로, 원본 객체가 변경되는 부수 효과가 발생한다. 외부 상태를 변경하지 않고 외부상태에 의존하지도 않는 함수를 순수함수라 한다. 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라한다.
